/**
 * The `tls` module provides an implementation of the Transport Layer Security
 * (TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL.
 * The module can be accessed using:
 *
 * ```js
 * const tls = require('tls');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v17.0.0/lib/tls.js)
 */
declare module 'tls' {
    import { X509Certificate } from 'node:crypto';
    import * as net from 'node:net';
    import * as stream from 'stream';
    const CLIENT_RENEG_LIMIT: number;
    const CLIENT_RENEG_WINDOW: number;
    interface Certificate {
        /**
         * Country code.
         */
        C: string;
        /**
         * Street.
         */
        ST: string;
        /**
         * Locality.
         */
        L: string;
        /**
         * Organization.
         */
        O: string;
        /**
         * Organizational unit.
         */
        OU: string;
        /**
         * Common name.
         */
        CN: string;
    }
    interface PeerCertificate {
        subject: Certificate;
        issuer: Certificate;
        subjectaltname: string;
        infoAccess: NodeJS.Dict<string[]>;
        modulus: string;
        exponent: string;
        valid_from: string;
        valid_to: string;
        fingerprint: string;
        fingerprint256: string;
        ext_key_usage: string[];
        serialNumber: string;
        raw: Buffer;
    }
    interface DetailedPeerCertificate extends PeerCertificate {
        issuerCertificate: DetailedPeerCertificate;
    }
    interface CipherNameAndProtocol {
        /**
         * The cipher name.
         */
        name: string;
        /**
         * SSL/TLS protocol version.
         */
        version: string;
        /**
         * IETF name for the cipher suite.
         */
        standardName: string;
    }
    interface EphemeralKeyInfo {
        /**
         * The supported types are 'DH' and 'ECDH'.
         */
        type: string;
        /**
         * The name property is available only when type is 'ECDH'.
         */
        name?: string | undefined;
        /**
         * The size of parameter of an ephemeral key exchange.
         */
        size: number;
    }
    interface KeyObject {
        /**
         * Private keys in PEM format.
         */
        pem: string | Buffer;
        /**
         * Optional passphrase.
         */
        passphrase?: string | undefined;
    }
    interface PxfObject {
        /**
         * PFX or PKCS12 encoded private key and certificate chain.
         */
        buf: string | Buffer;
        /**
         * Optional passphrase.
         */
        passphrase?: string | undefined;
    }
    interface TLSSocketOptions extends SecureContextOptions, CommonConnectionOptions {
        /**
         * If true the TLS socket will be instantiated in server-mode.
         * Defaults to false.
         */
        isServer?: boolean | undefined;
        /**
         * An optional net.Server instance.
         */
        server?: net.Server | undefined;
        /**
         * An optional Buffer instance containing a TLS session.
         */
        session?: Buffer | undefined;
        /**
         * If true, specifies that the OCSP status request extension will be
         * added to the client hello and an 'OCSPResponse' event will be
         * emitted on the socket before establishing a secure communication
         */
        requestOCSP?: boolean | undefined;
    }
    /**
     * Performs transparent encryption of written data and all required TLS
     * negotiation.
     *
     * Instances of `tls.TLSSocket` implement the duplex `Stream` interface.
     *
     * Methods that return TLS connection metadata (e.g.{@link TLSSocket.getPeerCertificate} will only return data while the
     * connection is open.
     * @since v0.11.4
     */
    class TLSSocket extends net.Socket {
        /**
         * Construct a new tls.TLSSocket object from an existing TCP socket.
         */
        constructor(socket: net.Socket, options?: TLSSocketOptions);
        /**
         * Returns `true` if the peer certificate was signed by one of the CAs specified
         * when creating the `tls.TLSSocket` instance, otherwise `false`.
         * @since v0.11.4
         */
        authorized: boolean;
        /**
         * Returns the reason why the peer's certificate was not been verified. This
         * property is set only when `tlsSocket.authorized === false`.
         * @since v0.11.4
         */
        authorizationError: Error;
        /**
         * Always returns `true`. This may be used to distinguish TLS sockets from regular`net.Socket` instances.
         * @since v0.11.4
         */
        encrypted: boolean;
        /**
         * String containing the selected ALPN protocol.
         * Before a handshake has completed, this value is always null.
         * When a handshake is completed but not ALPN protocol was selected, tlsSocket.alpnProtocol equals false.
         */
        alpnProtocol: string | false | null;
        /**
         * Returns an object representing the local certificate. The returned object has
         * some properties corresponding to the fields of the certificate.
         *
         * See {@link TLSSocket.getPeerCertificate} for an example of the certificate
         * structure.
         *
         * If there is no local certificate, an empty object will be returned. If the
         * socket has been destroyed, `null` will be returned.
         * @since v11.2.0
         */
        getCertificate(): PeerCertificate | object | null;
        /**
         * Returns an object containing information on the negotiated cipher suite.
         *
         * For example:
         *
         * ```json
         * {
         *     "name": "AES128-SHA256",
         *     "standardName": "TLS_RSA_WITH_AES_128_CBC_SHA256",
         *     "version": "TLSv1.2"
         * }
         * ```
         *
         * See [SSL\_CIPHER\_get\_name](https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html) for more information.
         * @since v0.11.4
         */
        getCipher(): CipherNameAndProtocol;
        /**
         * Returns an object representing the type, name, and size of parameter of
         * an ephemeral key exchange in `perfect forward secrecy` on a client
         * connection. It returns an empty object when the key exchange is not
         * ephemeral. As this is only supported on a client socket; `null` is returned
         * if called on a server socket. The supported types are `'DH'` and `'ECDH'`. The`name` property is available only when type is `'ECDH'`.
         *
         * For example: `{ type: 'ECDH', name: 'prime256v1', size: 256 }`.
         * @since v5.0.0
         */
        getEphemeralKeyInfo(): EphemeralKeyInfo | object | null;
        /**
         * As the `Finished` messages are message digests of the complete handshake
         * (with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can
         * be used for external authentication procedures when the authentication
         * provided by SSL/TLS is not desired or is not enough.
         *
         * Corresponds to the `SSL_get_finished` routine in OpenSSL and may be used
         * to implement the `tls-unique` channel binding from [RFC 5929](https://tools.ietf.org/html/rfc5929).
         * @since v9.9.0
         * @return The latest `Finished` message that has been sent to the socket as part of a SSL/TLS handshake, or `undefined` if no `Finished` message has been sent yet.
         */
        getFinished(): Buffer | undefined;
        /**
         * Returns an object representing the peer's certificate. If the peer does not
         * provide a certificate, an empty object will be returned. If the socket has been
         * destroyed, `null` will be returned.
         *
         * If the full certificate chain was requested, each certificate will include an`issuerCertificate` property containing an object representing its issuer's
         * certificate.
         * @since v0.11.4
         * @param detailed Include the full certificate chain if `true`, otherwise include just the peer's certificate.
         * @return A certificate object.
         */
        getPeerCertificate(detailed: true): DetailedPeerCertificate;
        getPeerCertificate(detailed?: false): PeerCertificate;
        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;
        /**
         * As the `Finished` messages are message digests of the complete handshake
         * (with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can
         * be used for external authentication procedures when the authentication
         * provided by SSL/TLS is not desired or is not enough.
         *
         * Corresponds to the `SSL_get_peer_finished` routine in OpenSSL and may be used
         * to implement the `tls-unique` channel binding from [RFC 5929](https://tools.ietf.org/html/rfc5929).
         * @since v9.9.0
         * @return The latest `Finished` message that is expected or has actually been received from the socket as part of a SSL/TLS handshake, or `undefined` if there is no `Finished` message so
         * far.
         */
        getPeerFinished(): Buffer | undefined;
        /**
         * Returns a string containing the negotiated SSL/TLS protocol version of the
         * current connection. The value `'unknown'` will be returned for connected
         * sockets that have not completed the handshaking process. The value `null` will
         * be returned for server sockets or disconnected client sockets.
         *
         * Protocol versions are:
         *
         * * `'SSLv3'`
         * * `'TLSv1'`
         * * `'TLSv1.1'`
         * * `'TLSv1.2'`
         * * `'TLSv1.3'`
         *
         * See the OpenSSL [`SSL_get_version`](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version.html) documentation for more information.
         * @since v5.7.0
         */
        getProtocol(): string | null;
        /**
         * Returns the TLS session data or `undefined` if no session was
         * negotiated. On the client, the data can be provided to the `session` option of {@link connect} to resume the connection. On the server, it may be useful
         * for debugging.
         *
         * See `Session Resumption` for more information.
         *
         * Note: `getSession()` works only for TLSv1.2 and below. For TLSv1.3, applications
         * must use the `'session'` event (it also works for TLSv1.2 and below).
         * @since v0.11.4
         */
        getSession(): Buffer | undefined;
        /**
         * See [SSL\_get\_shared\_sigalgs](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs.html) for more information.
         * @since v12.11.0
         * @return List of signature algorithms shared between the server and the client in the order of decreasing preference.
         */
        getSharedSigalgs(): string[];
        /**
         * For a client, returns the TLS session ticket if one is available, or`undefined`. For a server, always returns `undefined`.
         *
         * It may be useful for debugging.
         *
         * See `Session Resumption` for more information.
         * @since v0.11.4
         */
        getTLSTicket(): Buffer | undefined;
        /**
         * See `Session Resumption` for more information.
         * @since v0.5.6
         * @return `true` if the session was reused, `false` otherwise.
         */
        isSessionReused(): boolean;
        /**
         * The `tlsSocket.renegotiate()` method initiates a TLS renegotiation process.
         * Upon completion, the `callback` function will be passed a single argument
         * that is either an `Error` (if the request failed) or `null`.
         *
         * This method can be used to request a peer's certificate after the secure
         * connection has been established.
         *
         * When running as the server, the socket will be destroyed with an error after`handshakeTimeout` timeout.
         *
         * For TLSv1.3, renegotiation cannot be initiated, it is not supported by the
         * protocol.
         * @since v0.11.8
         * @param callback If `renegotiate()` returned `true`, callback is attached once to the `'secure'` event. If `renegotiate()` returned `false`, `callback` will be called in the next tick with
         * an error, unless the `tlsSocket` has been destroyed, in which case `callback` will not be called at all.
         * @return `true` if renegotiation was initiated, `false` otherwise.
         */
        renegotiate(
            options: {
                rejectUnauthorized?: boolean | undefined;
                requestCert?: boolean | undefined;
            },
            callback: (err: Error | null) => void
        ): undefined | boolean;
        /**
         * The `tlsSocket.setMaxSendFragment()` method sets the maximum TLS fragment size.
         * Returns `true` if setting the limit succeeded; `false` otherwise.
         *
         * Smaller fragment sizes decrease the buffering latency on the client: larger
         * fragments are buffered by the TLS layer until the entire fragment is received
         * and its integrity is verified; large fragments can span multiple roundtrips
         * and their processing can be delayed due to packet loss or reordering. However,
         * smaller fragments add extra TLS framing bytes and CPU overhead, which may
         * decrease overall server throughput.
         * @since v0.11.11
         * @param [size=16384] The maximum TLS fragment size. The maximum value is `16384`.
         */
        setMaxSendFragment(size: number): boolean;
        /**
         * Disables TLS renegotiation for this `TLSSocket` instance. Once called, attempts
         * to renegotiate will trigger an `'error'` event on the `TLSSocket`.
         * @since v8.4.0
         */
        disableRenegotiation(): void;
        /**
         * When enabled, TLS packet trace information is written to `stderr`. This can be
         * used to debug TLS connection problems.
         *
         * Note: The format of the output is identical to the output of `openssl s_client -trace` or `openssl s_server -trace`. While it is produced by OpenSSL's`SSL_trace()` function, the format is
         * undocumented, can change without notice,
         * and should not be relied on.
         * @since v12.2.0
         */
        enableTrace(): void;
        /**
         * Returns the peer certificate as an `X509Certificate` object.
         *
         * If there is no peer certificate, or the socket has been destroyed,`undefined` will be returned.
         * @since v15.9.0
         */
        getPeerX509Certificate(): X509Certificate | undefined;
        /**
         * Returns the local certificate as an `X509Certificate` object.
         *
         * If there is no local certificate, or the socket has been destroyed,`undefined` will be returned.
         * @since v15.9.0
         */
        getX509Certificate(): X509Certificate | undefined;
        /**
         * Keying material is used for validations to prevent different kind of attacks in
         * network protocols, for example in the specifications of IEEE 802.1X.
         *
         * Example
         *
         * ```js
         * const keyingMaterial = tlsSocket.exportKeyingMaterial(
         *   128,
         *   'client finished');
         *
         *
         *  Example return value of keyingMaterial:
         *  <Buffer 76 26 af 99 c5 56 8e 42 09 91 ef 9f 93 cb ad 6c 7b 65 f8 53 f1 d8 d9
         *     12 5a 33 b8 b5 25 df 7b 37 9f e0 e2 4f b8 67 83 a3 2f cd 5d 41 42 4c 91
         *     74 ef 2c ... 78 more bytes>
         *
         * ```
         *
         * See the OpenSSL [`SSL_export_keying_material`](https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material.html) documentation for more
         * information.
         * @since v13.10.0, v12.17.0
         * @param length number of bytes to retrieve from keying material
         * @param label an application specific label, typically this will be a value from the [IANA Exporter Label
         * Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels).
         * @param context Optionally provide a context.
         * @return requested bytes of the keying material
         */
        exportKeyingMaterial(length: number, label: string, context: Buffer): Buffer;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        addListener(event: 'secureConnect', listener: () => void): this;
        addListener(event: 'session', listener: (session: Buffer) => void): this;
        addListener(event: 'keylog', listener: (line: Buffer) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'OCSPResponse', response: Buffer): boolean;
        emit(event: 'secureConnect'): boolean;
        emit(event: 'session', session: Buffer): boolean;
        emit(event: 'keylog', line: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        on(event: 'secureConnect', listener: () => void): this;
        on(event: 'session', listener: (session: Buffer) => void): this;
        on(event: 'keylog', listener: (line: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        once(event: 'secureConnect', listener: () => void): this;
        once(event: 'session', listener: (session: Buffer) => void): this;
        once(event: 'keylog', listener: (line: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        prependListener(event: 'secureConnect', listener: () => void): this;
        prependListener(event: 'session', listener: (session: Buffer) => void): this;
        prependListener(event: 'keylog', listener: (line: Buffer) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'OCSPResponse', listener: (response: Buffer) => void): this;
        prependOnceListener(event: 'secureConnect', listener: () => void): this;
        prependOnceListener(event: 'session', listener: (session: Buffer) => void): this;
        prependOnceListener(event: 'keylog', listener: (line: Buffer) => void): this;
    }
    interface CommonConnectionOptions {
        /**
         * An optional TLS context object from tls.createSecureContext()
         */
        secureContext?: SecureContext | undefined;
        /**
         * When enabled, TLS packet trace information is written to `stderr`. This can be
         * used to debug TLS connection problems.
         * @default false
         */
        enableTrace?: boolean | undefined;
        /**
         * If true the server will request a certificate from clients that
         * connect and attempt to verify that certificate. Defaults to
         * false.
         */
        requestCert?: boolean | undefined;
        /**
         * An array of strings or a Buffer naming possible ALPN protocols.
         * (Protocols should be ordered by their priority.)
         */
        ALPNProtocols?: string[] | Uint8Array[] | Uint8Array | undefined;
        /**
         * SNICallback(servername, cb) <Function> A function that will be
         * called if the client supports SNI TLS extension. Two arguments
         * will be passed when called: servername and cb. SNICallback should
         * invoke cb(null, ctx), where ctx is a SecureContext instance.
         * (tls.createSecureContext(...) can be used to get a proper
         * SecureContext.) If SNICallback wasn't provided the default callback
         * with high-level API will be used (see below).
         */
        SNICallback?: ((servername: string, cb: (err: Error | null, ctx?: SecureContext) => void) => void) | undefined;
        /**
         * If true the server will reject any connection which is not
         * authorized with the list of supplied CAs. This option only has an
         * effect if requestCert is true.
         * @default true
         */
        rejectUnauthorized?: boolean | undefined;
    }
    interface TlsOptions extends SecureContextOptions, CommonConnectionOptions, net.ServerOpts {
        /**
         * Abort the connection if the SSL/TLS handshake does not finish in the
         * specified number of milliseconds. A 'tlsClientError' is emitted on
         * the tls.Server object whenever a handshake times out. Default:
         * 120000 (120 seconds).
         */
        handshakeTimeout?: number | undefined;
        /**
         * The number of seconds after which a TLS session created by the
         * server will no longer be resumable. See Session Resumption for more
         * information. Default: 300.
         */
        sessionTimeout?: number | undefined;
        /**
         * 48-bytes of cryptographically strong pseudo-random data.
         */
        ticketKeys?: Buffer | undefined;
        /**
         *
         * @param socket
         * @param identity identity parameter sent from the client.
         * @return pre-shared key that must either be
         * a buffer or `null` to stop the negotiation process. Returned PSK must be
         * compatible with the selected cipher's digest.
         *
         * When negotiating TLS-PSK (pre-shared keys), this function is called
         * with the identity provided by the client.
         * If the return value is `null` the negotiation process will stop and an
         * "unknown_psk_identity" alert message will be sent to the other party.
         * If the server wishes to hide the fact that the PSK identity was not known,
         * the callback must provide some random data as `psk` to make the connection
         * fail with "decrypt_error" before negotiation is finished.
         * PSK ciphers are disabled by default, and using TLS-PSK thus
         * requires explicitly specifying a cipher suite with the `ciphers` option.
         * More information can be found in the RFC 4279.
         */
        pskCallback?(socket: TLSSocket, identity: string): DataView | NodeJS.TypedArray | null;
        /**
         * hint to send to a client to help
         * with selecting the identity during TLS-PSK negotiation. Will be ignored
         * in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be
         * emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.
         */
        pskIdentityHint?: string | undefined;
    }
    interface PSKCallbackNegotation {
        psk: DataView | NodeJS.TypedArray;
        identity: string;
    }
    interface ConnectionOptions extends SecureContextOptions, CommonConnectionOptions {
        host?: string | undefined;
        port?: number | undefined;
        path?: string | undefined; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.
        socket?: stream.Duplex | undefined; // Establish secure connection on a given socket rather than creating a new socket
        checkServerIdentity?: typeof checkServerIdentity | undefined;
        servername?: string | undefined; // SNI TLS Extension
        session?: Buffer | undefined;
        minDHSize?: number | undefined;
        lookup?: net.LookupFunction | undefined;
        timeout?: number | undefined;
        /**
         * When negotiating TLS-PSK (pre-shared keys), this function is called
         * with optional identity `hint` provided by the server or `null`
         * in case of TLS 1.3 where `hint` was removed.
         * It will be necessary to provide a custom `tls.checkServerIdentity()`
         * for the connection as the default one will try to check hostname/IP
         * of the server against the certificate but that's not applicable for PSK
         * because there won't be a certificate present.
         * More information can be found in the RFC 4279.
         *
         * @param hint message sent from the server to help client
         * decide which identity to use during negotiation.
         * Always `null` if TLS 1.3 is used.
         * @returns Return `null` to stop the negotiation process. `psk` must be
         * compatible with the selected cipher's digest.
         * `identity` must use UTF-8 encoding.
         */
        pskCallback?(hint: string | null): PSKCallbackNegotation | null;
    }
    /**
     * Accepts encrypted connections using TLS or SSL.
     * @since v0.3.2
     */
    class Server extends net.Server {
        constructor(secureConnectionListener?: (socket: TLSSocket) => void);
        constructor(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void);
        /**
         * The `server.addContext()` method adds a secure context that will be used if
         * the client request's SNI name matches the supplied `hostname` (or wildcard).
         *
         * When there are multiple matching contexts, the most recently added one is
         * used.
         * @since v0.5.3
         * @param hostname A SNI host name or wildcard (e.g. `'*'`)
         * @param context An object containing any of the possible properties from the {@link createSecureContext} `options` arguments (e.g. `key`, `cert`, `ca`, etc).
         */
        addContext(hostname: string, context: SecureContextOptions): void;
        /**
         * Returns the session ticket keys.
         *
         * See `Session Resumption` for more information.
         * @since v3.0.0
         * @return A 48-byte buffer containing the session ticket keys.
         */
        getTicketKeys(): Buffer;
        /**
         * The `server.setSecureContext()` method replaces the secure context of an
         * existing server. Existing connections to the server are not interrupted.
         * @since v11.0.0
         * @param options An object containing any of the possible properties from the {@link createSecureContext} `options` arguments (e.g. `key`, `cert`, `ca`, etc).
         */
        setSecureContext(options: SecureContextOptions): void;
        /**
         * Sets the session ticket keys.
         *
         * Changes to the ticket keys are effective only for future server connections.
         * Existing or currently pending server connections will use the previous keys.
         *
         * See `Session Resumption` for more information.
         * @since v3.0.0
         * @param keys A 48-byte buffer containing the session ticket keys.
         */
        setTicketKeys(keys: Buffer): void;
        /**
         * events.EventEmitter
         * 1. tlsClientError
         * 2. newSession
         * 3. OCSPRequest
         * 4. resumeSession
         * 5. secureConnection
         * 6. keylog
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        addListener(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;
        addListener(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        addListener(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;
        addListener(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        addListener(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'tlsClientError', err: Error, tlsSocket: TLSSocket): boolean;
        emit(event: 'newSession', sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void): boolean;
        emit(event: 'OCSPRequest', certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void): boolean;
        emit(event: 'resumeSession', sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;
        emit(event: 'secureConnection', tlsSocket: TLSSocket): boolean;
        emit(event: 'keylog', line: Buffer, tlsSocket: TLSSocket): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        on(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;
        on(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        on(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;
        on(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        on(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        once(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;
        once(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        once(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;
        once(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        once(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        prependListener(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;
        prependListener(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        prependListener(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;
        prependListener(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        prependListener(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: TLSSocket) => void): this;
        prependOnceListener(event: 'newSession', listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void): this;
        prependOnceListener(event: 'OCSPRequest', listener: (certificate: Buffer, issuer: Buffer, callback: (err: Error | null, resp: Buffer) => void) => void): this;
        prependOnceListener(event: 'resumeSession', listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void): this;
        prependOnceListener(event: 'secureConnection', listener: (tlsSocket: TLSSocket) => void): this;
        prependOnceListener(event: 'keylog', listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;
    }
    /**
     * @deprecated since v0.11.3 Use `tls.TLSSocket` instead.
     */
    interface SecurePair {
        encrypted: TLSSocket;
        cleartext: TLSSocket;
    }
    type SecureVersion = 'TLSv1.3' | 'TLSv1.2' | 'TLSv1.1' | 'TLSv1';
    interface SecureContextOptions {
        /**
         * Optionally override the trusted CA certificates. Default is to trust
         * the well-known CAs curated by Mozilla. Mozilla's CAs are completely
         * replaced when CAs are explicitly specified using this option.
         */
        ca?: string | Buffer | Array<string | Buffer> | undefined;
        /**
         *  Cert chains in PEM format. One cert chain should be provided per
         *  private key. Each cert chain should consist of the PEM formatted
         *  certificate for a provided private key, followed by the PEM
         *  formatted intermediate certificates (if any), in order, and not
         *  including the root CA (the root CA must be pre-known to the peer,
         *  see ca). When providing multiple cert chains, they do not have to
         *  be in the same order as their private keys in key. If the
         *  intermediate certificates are not provided, the peer will not be
         *  able to validate the certificate, and the handshake will fail.
         */
        cert?: string | Buffer | Array<string | Buffer> | undefined;
        /**
         *  Colon-separated list of supported signature algorithms. The list
         *  can contain digest algorithms (SHA256, MD5 etc.), public key
         *  algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g
         *  'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).
         */
        sigalgs?: string | undefined;
        /**
         * Cipher suite specification, replacing the default. For more
         * information, see modifying the default cipher suite. Permitted
         * ciphers can be obtained via tls.getCiphers(). Cipher names must be
         * uppercased in order for OpenSSL to accept them.
         */
        ciphers?: string | undefined;
        /**
         * Name of an OpenSSL engine which can provide the client certificate.
         */
        clientCertEngine?: string | undefined;
        /**
         * PEM formatted CRLs (Certificate Revocation Lists).
         */
        crl?: string | Buffer | Array<string | Buffer> | undefined;
        /**
         * Diffie Hellman parameters, required for Perfect Forward Secrecy. Use
         * openssl dhparam to create the parameters. The key length must be
         * greater than or equal to 1024 bits or else an error will be thrown.
         * Although 1024 bits is permissible, use 2048 bits or larger for
         * stronger security. If omitted or invalid, the parameters are
         * silently discarded and DHE ciphers will not be available.
         */
        dhparam?: string | Buffer | undefined;
        /**
         * A string describing a named curve or a colon separated list of curve
         * NIDs or names, for example P-521:P-384:P-256, to use for ECDH key
         * agreement. Set to auto to select the curve automatically. Use
         * crypto.getCurves() to obtain a list of available curve names. On
         * recent releases, openssl ecparam -list_curves will also display the
         * name and description of each available elliptic curve. Default:
         * tls.DEFAULT_ECDH_CURVE.
         */
        ecdhCurve?: string | undefined;
        /**
         * Attempt to use the server's cipher suite preferences instead of the
         * client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be
         * set in secureOptions
         */
        honorCipherOrder?: boolean | undefined;
        /**
         * Private keys in PEM format. PEM allows the option of private keys
         * being encrypted. Encrypted keys will be decrypted with
         * options.passphrase. Multiple keys using different algorithms can be
         * provided either as an array of unencrypted key strings or buffers,
         * or an array of objectu
H*ÅìÑ>·ç×ö¨I4„4:ÉÙq7ÓöÉ¼Õ–‡“}êE9á_©:ûû÷täº˜Ñt¢á0q°A·êßóüÒ,@óOJ@õ…ReZï˜æéÀÇ¡¤×º@0à…6½,	a¥´û}ŠßO¨Ç:Y$¹t'¯x¶zÊ3<ü+«mÄÓPº¡Rë°æÜ"UÀ'|è¹Ø°ãKœÖÅç°ã\Q{“™3+÷§"y¬kl¾€"ÁĞ›w	_”1¯<ê  GJØ]û`b¥m¾ÌîĞ“P=°ÀTj°Àëû;>dh'^¬şBÁm°Úäô—+%|šÿ#†Á“s²:ãZ‰×:mzFHr‹òÀæ.ôN5ìx€Aíe#DÜ5"ZNŸ¨*æö¸ySôNè Dm* bt5®›2ÑºÑ©v|ZÃcS"¦×ÿŒÁ¶sşlPƒ†(Ûí,;%çG©[û€TÏº×ğÚ·ô]€z¬{Á’8ìƒèôŞÄˆ‘òÄåÉDÌ<r²;9-Õé'sf°á•24ÙÅÛÏ“íÇ£ª)Ÿ,¹~±}9ÜÕı½Ğ|¤Ê{zØ‰LÅGÇ>\Æƒb#ëmÄÑOüğa»ŒÚw ±ß¿V#GÎ Ëx.ğ0ÕìÀº¬µ…¶dÒ’Êw"OÑ¤–èYíI µl+æt$±@ÍÆ¨êU{3È^ÎpEØìær|cÄ?eŒÕ‡í•üeW'nnÿtœñ#Ôv-!ñF}VWK–lº†Ñ9ÖE§Ù>˜S‡?ƒ¢nHît–3Bä^ÔdPfC^(¨G¨jS¼|ØÂÈÛ…êşgÊi8å•j|BÎ-H6tñ=¸¹Á ¼Û„1g.™J ¸uæ/*J£¯Ò¿\®¹çµçb{Üı™?lJá>§ÇèçĞ*Ïv[^î4mrÓÜE"Û4ãZG?WÎÑ‘ºÙ4İòÑ‹'\³¥ö§8—LFæ_ô2KÙ–+ÃÕÙ]İŞ&HîçÕ­ ˆ£"âĞÂ®ßgA\ÊÿZÔÖÛ-&¢&Zùã¿</¾bCm*Ù;UPÜù+Á©ºu•?º“³ø° 7¢v7K­Ä]2†C¤-¾wê€pş™Êè¦új$Ù¸…s¬ÌT°&E¦ìQçÑíq?ŸègÑğ±£	IE4¸—ÇTTz¼“O[I”¸*@¡ @û–/FŠÄ?˜œñPOæ¥¢5t]a¶áûİt¼rÉ·ñšiáñäiÄàRuq5©€Ä¼É”z'œ•ÅüĞ8K:å¤KÿÙ¢¶ªDC¾ğ3(ÈÄË—‰g¥OaJŞÕˆãÚlûó‘²U-ŠhVÿR
ÿtYz+†âÌ#êùŞ†²m{”;qÉÜÕQ€öıÑ†Ó‰¾(rÇo9á_©:ûñøôË…&÷¢d>£¶ÙÆùü‡oAúD`î”PnIãA×ğüÅÛª÷” Àº^ßEB$ñÛ«)Ã]«ñ=s$¹t'¯x¶ÀKlBM®Tx«,ŠÓFM§à³´Ù%BÛ6u¦·äÿFÙšÚá´ı\Q{“™3+÷§"yû^wûÓ9ÃÊ‹aGB”1£3¯¬2GVÎp²1¥>î‰Q§–Ğ*Ò§jà’I»¾ij'BloX­¬SÖ{¡ÁãşÙ	Æ:j<šû-M£÷¬x¢qéHÉÊÖ1>mZ_8ÂşÕær-f©8Æ ¡6]igÛ"ZNŸ¨*æü²
vâË)uq.f	RÌòy”J´P”ı9-<pòÇ¶Ï€S²{ªbPƒÏ3Ğ©sc&åX©Ÿ¦­*‡ÿ×[µˆã½Ã3À„¿ìƒèôŞÄ‚ã½ÚÂãÕB<o¥~eE¾ºhTs1ø¸•fv±ï‹ŠÖLê”£élÇO¹7™¸l.™‚õ½Ğ(èÇ}~ØœLÅZÈ9’²&jùîÄœ¨©aôAÆ•Esò©„Ö¡8‡>öÓ:ß®™e«ä¤ƒó	¬Ş™mšáÂæ¸N'¹u'“£xeÿ]’ƒ«åRB{ ’!«) œà¦<)/‚ˆÕˆ¨×ïus+5¹óµ şv-+şkW\W+ÅNS/ÿJÃˆ_y‘Ë§w×A6ÕmÌS¸d"‘ÙaYÉtÔdP!
Kíö)8ß?™–ÓŒğşÒZö˜p:YÈ8I!:ş=·¯Ù°ºÏŠFEa2OJõ9 Rıu³|o¬PêÿÑıSğ©ò²J1Ü{ÚÔ¾T>må$ôˆğíŞ~pSEö4v|Ô×V,á5æ^P&ÎĞŒî×wÆ¹üïbüÊì·ó}ÓFÏ^ÿ#ÕÚÏq—Êú:p2İŞ&HîçÕ§( ¥‰"âĞÂ®ßmb]Û@ãOÀT“ƒOCîc·ø’/¾Oim*Ù4_ZñÓ+Ë©ú5ÕuéÜQ¡äRFyD¢5xóßÖt>|ÁCğeûw¹Å6F½Í¬¤ÕGòºÏ!I™ædîxS†µ9†Ãøg=²ÂmÑ’ôåF 4ó—J†+§†EP«=.£Ù¾À:9õ¨ÿ´ëÎ»teÂÀ˜e5ÃÀíOäéê¡A’ÌÛäiÄàRu{5ŞÂBŠ¼ˆ”00—ƒÅıŞ= U´ĞdÃ˜[õàÂ*Cü¥g(†‹Ÿ—âˆ]'3ŠšËA¯Ú1ºà]‚Ú3hÉ<»^
«8 $NÅ©‰wäCG©üÜ|q×/àñÿ?t£¬ÎáªÑÂÇ~‰.t¤"¡r¯¯§d±ûÄÒq ¬+n§«åšùú#JùX<÷‡W1 òÆ¹ğÈÆüø»Ó,;ïŸ5š
0[¶ÿVÑL¯”C>h°2hıxû:’|)_VºUyæ,šJ	åÎGİ¥ãæœvŸb\»¹ĞóòÆ›³ä¿Hx>)ÇĞub´æv<ô¾Ók†Ş3	CÀ¨)¢ª4OF>ÑQyàl€Èâ÷”Q	Ï¥ %óJğÖ>n?oâş™"Ü¤­ºF—NÆn%<Ä³9h_¿à®oñ0è†ÜÔ1}z@ZN,ÎîÑ÷5í@fı\}ÆTøfoJ¿^oAVNŞænæ¥û#v§H«5i{c6^?sƒştü4ºÑ©v|PÌNs"ç™ºÜ‰BºcøeSÑ„7Ç©sc$àI«_Ğ©ã~ê’J¶Ÿô RÌ?Ó€À|ìĞ­·ŒÁO£·•ß·Æ$s²u?E¾ºhTs1ø¸•fvœ†ÄÄ˜	©Àê¦"ÃO«7Ÿµ})ÌïîÑŸméØjfA—CÒMÕY2ˆ÷~"ı@¥ÄˆO¹¨"óBÂ—C'»­ÍÔ¢VWm‡SË+k¤›ª™I½¬µ†óvÇ’—_šµŠ¯K¸T;úq,‹ú0wù€‰¼ÿB><ˆs¥p”¥N¨&|0|NšÈCÄèÛÿ9v)¸Yä´Zv†À_2 <+şkWVWK–lóW‘Ø'Ú[æÂ9× 6†(ı<-ïiš*zÔ#C}øí2*Ó8Ø–‘‹À¹ş&Å4ßÀ¤><Ê7Ydz¥X›‰ûò¹•Šnj'BS ¯:ã9=ZúZ©ûT«¹å³ğtÖ4æİ³;k O¤>­— ºáÎ*İ4yhÆ8r“´;,¨{ kFW²èî˜PwBüü¡-\ÕÑ÷öâ`ÖÊ
º1KÛßu—Ş×Q¹¶!Dî©”à@¢Ùp«‡¼ÊqE…@õTŠÄŒti³#šÒ’/¾bCm*Ó4?	¸h„©ì`›/´ƒ2™‹äRFyD¢5xöò§Y|ÁCğeû0ü‘YõˆÂéôÚJ?òá¼o·‹åj.Ûª”¿0sjÚ±ŸÔ»åOv³Ò	ÒL)º‡HRRñÓy@âAMÃ¾Í`\g ÚŒvËœ§Ï©¥Š5tHe¤ âè=¼nÖ³ºó¬´·:…§&{tŒBÇùÛÇs!—ÑÒıÖ6]n¶ëN°Áç¡ M°à3m†ÃŞÙ¬X1FZ/ŠšËA¯Ú;º ÂÿN!tú^^älKEdŠï‰fıQGëÙ¢ı{…Tÿ‘RÓ·‡ø˜ÙÕÖ4ˆ=9’,Å:èõç>§ôŸÍc®¢'¬dçø©”¶¨È,¶DqÿÆLsK§‘ùï‰Í·£òÀö§;
a¿âj‚ÄHïÜG!kúY0rı=åu—qlX¨Rn«,‘‡AIœ­F‰ì¬¨±\•b<èğ°·	Ù†Çí£øP)…‰uÇŠyH{ˆ*víÓ%ÉÊŞwLOÆ;¥y¥½fM\ÓÌtëq»Î©»ğyêTj°ÀáÖ>n?oâş™(’ÁÿèÄ‰ aoÎç-_¢÷à|‚ÊqÛÊxgAX;Ïı”ì)÷N(ìqˆ Îf-9‚s"E
Ÿåk¿öğ<3òTïHn;:.s
z!ƒ±8ÑJõ˜ä&07v¦ƒÉºŒS»u§qQ˜'Ûé6x/éF«VĞ¢ä0‹ó™_ğœå»Šó7¢’-õ‘ñ‰ÖŒÖB³äÀ¸ÓXƒ$iùr.<Ò´'4>°ìØ*sÎƒÈŸÏ^ó­ÄFÍOeÿ7Íğ)|Ö‚Ü½ÙÜm¤Ş'1XÖÏ$½YAzRÆ÷*`¸ ¼Ä…®¾aÏKÉĞJf¦»ÎíBÉ˜c.àİÖåÊ_¬£µËâlÇŠ™L,_š£‡£V¸N-´jb“ì0päĞ•¡èCjs‡ ä Š¸©4|"ÎLv³“,¨Û•â4r,(ªóıl†Z#cRn¸"–N[lôW’ÿ%ÖL®È3—A{>Ÿÿ+-ôgŠaŒ1šd#
(ñönS¼|ØÂÈÛ…êşgÅ%^Ø¤Ì9|‹yZ!nÄt¶¤À½¼ß‚_/EA ı ı8*Hê¥–à8×Sğ©ò²J1Öt¢›Ç+l#E¤jôÇE°¨ïoÉfNEñu~|ÖSfí8ôP.ÂÌ‡ Ì9¨´ä'öÛ÷ñô8ÔÒPó2”Êˆ%»‚×D8wİc¼ç‘â@YëÆvÏúÂ®ßg‰@¬F^ßNŸİ'i¯cXòªÆ_i÷\#(&ÙuZ´{•ğº:×uÿĞK³Ü­
yç5*@­ŠßQ8ÏC™#û#ñ€<òÄéò›Nä¸—d¶®=ÿjK‹ÆQçÑí{?EÚ»9ƒİ­  t·ÂÊZ~½H™ù+¶^†úÌG|JŠÚŒvËœ§Ï7‰¥ëft-á ¢„t›a…¯·òCØ´½¨i‡¥ !2s—‹Şùˆ×z'›Ÿ–ãĞ hçñMãÌëâªA ´¥$mÔßÖÑ¡H”$HdLÆÖËá™wïäXÂ¶W(€o@îXÈ}X]-ƒàÊ6°©À¤“­|fƒw2ÃÃÔT¿‡û”Ø‡Ü@8‚,máìj©¾¤rå ‚Ëa÷ë0mâ «üÑä¯›$¶D3ºÆ é”óïİÁ©¾‹á‚ÛoòoB$ñÛ«)Ãš7ò•Y0a¹Jd)¾i¸aí)ü+«mÄÙPdW‰¶Jİá¦²İ?KĞ&<¾İüâGœÖÁê°± XeÇ“00à¯0uTº~z¾#Ç×3@Ô*³,¯¯jGQÕÊVxö{îÀäÚQ< 9äÀR£¾;n+BmhHâ½DÁ|¸ÈäùÃÈC<Î³K-ê²à6ñôKËÌ:>O@KN*Âûİ
â(æ)ë^}…T¯wcJñ"ZNŸ¢%ËÜ²y3§U«e~n^6O(BÆãf˜XóTı3t‰8kê’ÅåŒ•U¢c£>µŠ&ßàz~#ØM y•²ù7‰ó”Y¤Ÿ¬ÙxŠpQÁ’8ìÄ­ ®ÇD€òˆÅşÁ^)n²3/-Àû!6uç¢• =Ğ–ÎƒÌLšÑæ»ˆ1¶q„³h(™™‘ÄĞŸ(¤ˆ>?‹yÒKÓ:(±c)ù«‰•
¨±(÷FÈÏ'°±‚Ö¨C4NS»n.öş:ÉôĞJ¤§±Ÿó$ÚŞıA9MÓ­‡¢hıX:™{0“êvmï„ƒõ†x>sÆsäpE×æËX|cÎ?ßœXÄ¢•Ë&Yb7%ëĞ¸@j‡Æ_2mf»8Å\>ÿJ—Ê*ØZæÉ>e>ÌşnyôcÙ"„$˜!#Ciæñ(?İ9õèÈÛ…êşg—Ê~Ø¬›p(X‹80uö|´íÜ³ùŠ“Em.PQ\RR‰À|~ ³Z¡œ¿°¢ìòôcÖÛıêb3L¤>¼‚ºëÜd°¢u?2™&¨9åW8‡Ù¼˜/Ë®²àk\òËñ¾âvÃÇ_õ?ÕİÉf—€‚B5aİ‰n çå@
Uğİj§–çœ&GM]ÇmŒFAÖ™biäcKå·Ä_kû[b4*ªG3U…¿XÁàéuÛpî“[öØ­ =DígxLªßÃ@|„¿0¼?·èF½Í¬¦›T½•ÿ!KøƒÿjK‹ÌQ„¿#zRÏ§#•Áô±	T|¼—
õi|V³—Pa™¼+?¤Yö‡.JØ•Ù"‚ÒâÏUT£Ê»#:o^ ãÀ0òjÄ¢ÿõ´¢¡-éÊRu{5ŞÈBŠ¼‚”f)Ò˜Ûäİ6Câ¤\ø‰³®¼²ì6}ÃËŸÔ J›>HS3GÃÔá;üòR÷b¯_®G²EA0‘ùÚmëLæßºópqƒy>ŞÊIºÆîÛ–ƒ{ÉBá_©:ûû÷7«şËåu¾ì'{âÔö°š¦…â,¶D3ºÆ*ƒO’âèÛÆïƒ€å@Í¢ ¡;Bd—’å`ØDáÜZ6wê]3b¯,ş4”9`E¹B{î.–HšäF¥¢¥È#FÙ.eè²Ûõù‹“Öç¼ço•Ÿ8bà®3<D´itû‡kÇÍŞcHR”1§y«ï4rSé1ëyäpªÚæİŸyÒ¸T*åB®½rp+CoR¤şUÛm£Ë­ó— ‰neZ‡ı~C¯ö <¼4õ]ˆÙÛtmam"]~‹½”I£|© èF6ë*¡6]cJñ"PA²‚*æö²y3§î14~|C4hĞùw•³ÑË#:‰y~¦‚Ï»É‡N¹cî?2ûÏr©6;g¨ï]7úà­~Ïº×ğÚ½ô Ï$ÔÁ8­ƒ» ŒÌQãô•ßãÆ^‚!t°;? Ñº&4~¬ñÔ29ØÅøùºCøĞé<Ÿ 1°t‚¼)*™Ğï§ßŸgâˆjwõõ	—YAzRÆı*)í¼ÄŸü³.õMÉ“Rn½°Ãš™J?GÑ‡~.¤İxÎîÒB¢³¾Ìö$Ñ—ÕHmNßá£LíO&¿zbìb$ïˆ«èCz^ìsäpEØìærvcpF”Ù—¨Áâ467!½¶¿AwÔÍU;}Znª.VÓU-ôšØ"ÑXæİ%˜s†>ÂSÌ&h¼p˜-Œt”**(ÿî,S¼|ØÂÈÛ…êşgÊJ1Øö‰m)BÅ<Yd|íoø¾Ö§¯ŞØ`$F‹O ı1ú/,Aí¥‘¯P¹S³å»÷eÖ(çÒ¡D8pK,jôÇEº¨*91!¢u?2™,¨q aP$ÄĞîÎ%Ç³²ò'áÛ¿Û8—FF†Oºqßf¥†%ÒÄ×p2İÔ&Bî§ÒŞvfB¶bÏúÂ®ßg‰@¬FAĞ¢õ?ÿd[šÒ’/¾bCm*Ó4UZ±Ô_­Úìd›.½Ó2™‹äRFyD¢5xùÕ­0¦tõe¾…l½Í¬¦›T·²Õ+K¸„c“šÈBà‘À[?ŸèmÑ’ôåL6*4ù—J†)ôØm™ù-§A"@†ğ±:Jñšÿ§ãàŠHeõà¹5=Sc¡İªÆ ¦wÖáğ¸É¶ÿ«9®&7;‘š…øÇ×aiŸØ¥Ÿb +ZûåF£^ú&‹¨Eƒó"zÕÂĞÙæC=A3AÅÙê”oûôT¹.†nöXî8CG"ŠûÄ6°
çÛöı94×TwqŒŠ\}€¿‡ÿØÕÀ’|×Bá_©:ûû÷7«şÄ¨÷¢d>âIÍøîÑâØšcZùX²Ï ]·Oøú‰Ôï¹ì_¡ÜEòoB$ñÛ«&Éš,}¡Üs$¹t'¥xÄ0”l{XKüNcîm°¿#T·N’ëã¢İ"F•-nè°ËşóFŸŸÛç±ñ\R)‰Ÿu1ñµ%uXµ*hÿ€F¬Ş3	J”~ásê¡# QÔÌDu«>ÇQóŞŸ:Ñ£$äÌ¿³~>*Fk.¡¿O“j´ıè	Á‚+a<šüKyC¯² o´"õG†ĞŞtq~AD~Äû”Ã0êI-©WwˆNäu	>J¥P"VÊåoæ¢ú<3äHå osa=zNÍ±f™[ºD”û 9ÀN0v¦šÀ¦ŒƒB÷sùaY„ƒ_´©6;g¨åWÚàë1º“]²ğ³Ä7|ë’8ìƒèôŞÄ‚ÎÚ‘·‡Ìh:÷1kÑÿh t«ëÜ)2œ·ÎÙƒºÀê¦"O#°eÍ½f.™‚õ ÖŸÍeåÜwpÖò#—YAzRÆ÷ G’@îÑOüğa»	Œ¾Is·äÍÚªG.4Â ˜b$ê•vÛ ÎC¿¯£ËùjÊ‡™B"^š•®•N©zú,ƒ£raà‡ÈîÍT>ª ²aKËà§",/‡|D‹ÕŠû¸€uY6`ëY¶ñ#™ÛI"-Cx»kKÖ N)é×V+ŸZ°È9ƒA>œ9Ìô=b¼q–3št’+f72[şY¬r~×2œÂŠÉ¥©n™ç"tØ¤Ì9|‹ydZñt¶®Öõ¯‹„T!sz)QØ Rıu³|epàÒûıSğ©µ÷B“(ûØ¥Od*_Æ?² è¨Á*È}XNä<qwÙ‚<¨{ kFWˆ•ÈÃ²PwBüü¡'\¹Ö³â8ì55ê3iı47ğÕm“–’TM—a	¢ †ĞB@ñÙqøßÍùˆ0KBÌõBOßJ‘–&&­0ú¹Ü!¯sL k—'P)‚¿T†ìî
ÆwûÁZ÷ô·8åfvM­’ÁP:ğ(´%üÅuû‚İáçÏOù¶øKøƒÿjK‹Æ[ç±¾8qBÚè;À€úôWÓ—J†)ôÒI¼«<·¯÷‘>VÌÚß?ŒÒæ›IHæ¥ª*3S¨ôêÃ'òtÍº­ò£´°>¥u/}›ÈÏîŞÑ`f“ŸÒ´Å;K:úíMş‰©â»Hüê5lÃÙŸØ®‘5NMvDÙÓ…¯ŠiÿæX²W+Œ2>‘^
«8
	dÅ©ƒxÉiG©öÜı94#ÄÌÒY ¿ıÑ’Åšr”;k¨îA†àÚ«ôË…&÷¢d1èCàÒ©”¶¨È,¶N3Ü‰K Oã^›ÿøÇÜã÷šåŞ¸ò;
añ¯ÇZÃÃDò•X=$íU7lê,¶<†9fX]üSx«,’’HFŠ¨İê±¦É8CĞ$u¦µÚğ¹¿™Ç¢´±F‚‚ybõª!}N¨*mû‡>ÔĞ3IHĞ;§0¤ª"q·]˜1¥>î‰Q­»ğyêTj°ÀáûRjnJ~6 »Æ{´ÈøöFÑ”nayŒæjB¤õîÛq¦Ét>.J%!]~‹½”I£|£fÚQ}Æ@Òs0¾Q"vÊåz²¿ı7s§Aùe	thksC4gÌãJóXŸ§[VPÌNy"¦×ÿ†Ág¤oägZÑ™b¸'5s…"åWĞà­~Ïºİİğ·ôRŠpQÁÕ}¸÷„‡ªÁ]¦ãÒ˜­‡u™.|²ik4”ï&6w±öĞ"g±ï‹ŠÖLê”£écÇEHÕ7Íğ)|Ü‚¼îšĞìmáˆ~L‹Œ@Ø@+)‹§~#÷®— ®ğ,ôQÉĞOi´±Ÿ×¬V3É]æk¤› ™íîğ«åmÈÜ;”ôÌğ5’hú>bÇ£0$¦]°”«ÿTps†'¶% ˜ìB r(+‹?VšÏçÛª"e2®å´J/ÔÎ\7aEn¾kÄPT?ÿDzø™QkŸæw×K9øGÌS¸n-¼&Ù(
º1‡7),mıç$vŸfØ€‡”É¯¿)Œç"tØ¤Ì9|‹vnˆ=øí“õù›ŠO/FQ˜GL:ğ7*Z­¥œ¾R²¹è¦÷B8–{åÔ¾I#gEHê# îíÎ*Ü3hgÑumwÓÜVcü2áEK$W×Í­İ$L£Öü¡'\³¥ö§2—3Éù>˜ÃÃq›‹™pf•›&­¦™áGKWîÉ"¤…Œí‹.\JŞ	ê
Õ†Ø1:«'öøÁ_aùS'C,xa¿‡ë©ºu•?º“³ä8¢|+¼–ÙQ.Á¾e»ë—sıÍ‡åà›Rò¸‡d­ÆD«jÊ¢•äqpSŸ¨#„Ş¸¥H6*4ù—J†)ôØ)4IÜùy@âAMÉ¾¶"Š—É"ƒÓãÏ_[í¥©#tI~¤ä¢Ú;òuÀªªòÊá°ä9¥ r(5ŞõÎİq'†”–õ×'KhUâìM°Ì²°ª-iü¥g(†‹Ÿ—èÕ3BQ}@ÉÎ‚áÚsûó€²\&Éy@ïHçqYA!§¤]äCG©öÜı9>ú~wqŒ€\ÓöÃ¼êÓÉ“P'‰!p¯©{¨û£îô˜Àt¡ç62â…½©ÇùëƒiZ¶LöÆ[e§X„âïÆÑª³È÷	Äö¼ov£”ù)‚ÖUóœ_2jıO<fä=Â<|fCL¼â œP	åÎGİ¥ãæœvŸOèğ°·ÙÖ•¨õ×]«£#sºõz<E¾dzùœ?ÏßŠzF×?¯7¥»f[\ÔÑUxäj«Í]§ß0Îê%äÀU¾«kq<Sz+ §Ç`´£‡ºF—NÆn%<Î¹K}Y¥æ¯¾=¨#ãt>.@]t‹İÇ í?æ0¹)×¹wcJñ"ZNŸ¢*†¦ó+rêê)y{m8
gƒñ`”PÿPı?=‰Fpb¦…Ä«Ù“I²bªdKƒš7Ş¥6x&äD§Y›àä-ÏûƒL±™ÿ±Š?Ï„’l£ƒ¼¼›ÄÂ°ò™ÄåÂŒh¡~%<šºsqªıÛ#;Ó‘ÂË‚	âãé>ˆ0­yˆ´)<šÃğ½Õ“(äËsšJÜN6Æµojû¢Í”ü¹/»WÄ•i·¦™š¹K9‡‚#‰·› ™íäğË¼$Ç™A?^Õ³ÎæMöQ-©mb“ëu$ì	œ•äM{'†s¬1Ø®N£<|'‹lQÓì™ª<6((¢şñMb‡Ë6nWg²)–PT öJÍQ)Ú¥Ì;›rÕ,˜Sù"a²óaYÉtÔdPfCT(Èç4+Ä2Ø‚œ‰Ğ¯¾gŞŒ&ê‰~3DÂ8I-uì=¯¬Àõ°ÕÃNn3G]ØSF±&ö<oA÷¥€¬\®ş„Ø²J1Ö{¨‘êf,h+¤jôÇEº¨xØ}YLí!vsÉÜ‚{ kFW‡ŸÂî˜'Ç³²ò=\è³ö§8—FF†OºqÕK†%€U3f¨gº¯šÿLPQá–8â’á“"RJÕ@óJÖQ˜Ü&rÃI·ø’/¾bCm*Ù4_Z£–z”ìé!özèÇ ©‹¦	5ã{xYùŠÃQ:ˆµ!àZ“Å<F½Í¬¦›T·åÙaøƒÿjK‹ÆQçÑí2~MÓª,’ÙîåN^Rfã—/ÔH_{ôPµp@ÿ_MFŒ÷†G|JŠÚŒvËœ§Æöë¯#2Uc¤ä¢Òt°hÊ·ºö…ÌÛäiÄàRu{5ÑÂH§–ˆ”2fÒÑ–´‘yNó¤HäÚ&¨¡¤Eòö"|ëÊÇä­E‘_^tHÏÔŸI¦š;÷åIŠ¸]hšyGè^^ã}
D%àÄ"©C3Åãöš¯xsš9%ŒŞÉXİÛã¼Õ–‡“rÇe9“ıo©µ¤7ë ™Ğc·¢-xâˆ¬ıİøïÈxFóz÷M ]¶^”óøÍÍ«ìÈàÀ¥ ²op¹ù~ŠÃDYŒös$¹t'¯x¼Xê9)ü+«mÎÓ#IF„¨Uİã±§Û;BÛ6<»¹Äõä“Öğ°ğ}•u á 0yE²dx¾Ÿ*ÒÛpPJIÚ~µ1¯ï%WÓ	‚}äl©ÌŠ¼ÚyêTj°Àë½i)Jz!O±ş@ÁmñÌøü Òƒ*%~—³eNêÆŒOñ=çWŒÌ!pz	D	6Î½Ñ÷5ñBfïFyMäx	c¢pAÖşo¢Û˜y3§U«eD;0.2D>!ÊåaÑWôC”î$5•N0q¦Ä­Å‡N²b±$S5Û©pi&ïE Nƒàî?º„H±”·¹Æ$È×8¾Ì½ºšĞ_³ä÷»·‡Ìh:÷;kb”û&se°ıÜ4|Ì—ÄÉ“¹İí®l+ÿuˆğm9Ãå«ÔĞÛ}áˆjpAˆJÜKÕY5•÷e8¸«Îƒ¹¢(õD‚Ğnh¥»›ß¿Wm‡SË+k¤›ª™_ ¥¼‡óv†˜ËE*Aß¯–µùY,ú{:“ñq$Ø1£Æ¨ùKw=s¦)¿§<8c­OpßÓúİï4:7£õ¹n•×7\-+şkWVWKœY)ù“ÊkĞI£ß6›6†(ı<-èn‹.<„1hnt(¨H¢`~–|ØÈÈ»Ö£°$ÒÊ^dÖµİ7m¦Sd:¢=øí“õó›êJ}&*‹ZZàd¥owŞZ”š¾°¨à¿ç1¢Û‘¬S-dDê>ô”àí“*é{Yï4g{ĞÌ\,ş:ìDGk‡ßÓø‹Hc€ÑÖ¡'\³¥ö§8Ik¬OºqÕK†v—ºQ(A˜b.¼¦’à@D@­Úk¸•Ø®‘2^FWÛI¼FLßT“Ø,rÃI·ø’/¾mIgó4_ZñÓ+Á©º•[óÀ^ñÇ¡F(Ñ5*@·šÊ@5€¹*µwÿŠnFé…Æÿ¦Ûr8ÄËšb ½×Wÿ#Ø’©’¨?nÑ«(ÑÑµ©
^D8ùÖÒ_]y )4IÜùy@âAMÉ¾–%VÏ”É1„ÈîH_£ò¢*8y³éåÉ1 'Äµÿ÷DÛ³£«;Ã R0-pœBÅòˆÀz#Ò‘âØâ AyóğH¾|£Uçâï Cü¥g"†ëÌŞ¦Hp[=„Šæk¯Ú;º Â÷bÆ9»^
«8
	dàÚ6¦ÛÕ¸™ºv`#8ÃÃˆUÓ †õÙÎ»­“rÇo9á_¦0ñÖİ7«ôË…&÷¢d4â>…½ç”óæ‰nBó_H3Îªj ^¢^œóé‰Ü½¶‹å@Â°
 "p¸”å)ŠÃ ó•C'a÷ h¯8å!„|{DXò_ã$—ÓEIÈ¦*÷¥ãæœv•b<âğËãòGÙ‚Ú¢±ô S)³¼b÷©8rR¸~vñkÖÌ‘qEKÇpÌSêïfG\]˜>î‰Q§–Úy—ê:%ä…ës{nAp=V£ªÜnñÚåÿFØ’>phÎú-B®÷®h¸2çBÉÊÑtjfD*ÛèÀIì:£G)ùQv•Sí6	½VgJN’üx§µ÷93èUUë*~t} FzrüâwƒHÿEÑ¤".9,¦ É¶À„¾rªmLÑŸ Ñícx"ì§¿°è0¼É»£šÄ‡>õ$Ó‚×0åÃè²‹ŠÁBªø”·Ó_‰h|¸i&)Àº!^ø¸•f|œÅ‹ŠÜL¿Úç¦/˜ ±cˆ´%|ŸÃòîÓ˜ŞfãÍ>hŒ—FÂZ.…²&G’@îÑOüğa»	Œ‘Hcò­…Õ¸N>GÉŸ+)á-ŞìĞI©ä¿…¸	¬Ş™mšáÂæ¸};³p!‚£f5¾SÂÈş†x>sÆsäpEØæËX|cÎ?ßœXæÔè9B-!¨¾ø#‚ÁS26;şkWVWK–f°g}Ò™QkŸæwİAD9™ö=-ènœa	Œ1†d#
aîá!*Ó|™‘ÈšËê¾‚Úö˜p:YÈ8I!z¢rº§Ö¶­•§0E/gWQØ XĞ_³|o£ZàÒûı:¶©¦úc“{áÂêO##Dá8ô„ èüÔlÔp]_çy?}Ï™Edí{ó^A ‡×ƒ½˜2Àü¸ätáÑü³ã4×Â
Pó?Ï†r›ˆ›2wİŒc»µ›èA9‰"âĞÂ®ßgéïMNÇŒlpàs6ø’/¾bCm ÖuZñÓ+Á©ºuÒzîãZöÙœGV`'çg,L¿–Î@9ÉJêeƒb©Ü_ï™ÆêïØG ò¸‰!¶ÇR¹#Î‚JÊûíq?ŸèmÑşïk1 4ù—J†)şÒv[‰«7âUÃò)Š™É$ŸÕá†_[÷àë''l¯ âöaâ>æ¾­ã
Ø¨²¥= R:9›‹„‘¢”2fÒÑ–´‘s¶¤°Q‰Uçâå *º¥3`ÃÙÚ—¡XÕ>BJÉÛ‡AìŸiîé[‹´X<Œ0ô
ÿpO	7ŠêÂ2°CèÃö¸|z×2"ØßÏX—ú‰éÓ‘ÓÁÚL7ƒ/9¶åvû¹²7ù±ŸĞt¹ç 0ÏcÍø©”¶¨È,¼$`óˆZeµÂ¸¤‡˜ÂİÈ @DŒöEòoH+Üñ«)ÃW¡ÜP6pÁ	d>Ì=ä!‰`UY¨_#¢wÄ«E«¡S”ãª¥İ"B•><½¾ÚõñJ—“Ñ¹Ø›\U)ÇĞub»ì|=û*?¾Ók†Ş9	!CÍ7¯>ê¢'[ÔÔxö>»Úã–œZ+¼&ù„G¿²tp=k ²¬DÅm¿Ú­şÑƒ<`rš³ dE®²¯zñ0òZˆİÕ'>g%!]~‹½”I£|£fçQl‘Oó}]3¾KmGÌ¤* ¹àyvÿFû);s`s^2dƒâb”]óQ˜ê7(ƒ *"é‘–é¤b÷>º6À·|³ƒ6;g¨åWĞê€TÏº×ğÚ·ôR€pä	€ßh ÆÅŞŞÄ‚ã·Ú‘·:æh:÷;kh”ºh^sq¸øß5Q¶Å‹ŠÖLê”£éfÍ*±d™ğb9…Ëò©ı‘ËmöÁsAÅß]Û]ò1’ùo2è¼Õº
¥¹/ünÍ„Cu»¿’À(zG‡SË+k¤u› ™ÿüüæœ$†Ş™mšáÈæ¸+¶w'‰÷0bå™•¦î7hëYäpEØìær|iãßœXÄ¨•ªuSU`ëY¶ñ#Ôv-ss¿&KÄBI9èW„Ø>Ú©Ëwœoœ#‹>ù:hîo˜-Cä^ÔdPfC^(¨H¨`~Š„×êéq—Øt™âÌ eÈlq,¢%½í‡çù‹“\>gEQÁU Kîuğ>oOçZö‘û¿Sæ¼òôR1Ãh¨×û(;EE½GŞÇEº¨*3¢u?2ˆ,½: kO‡İ×îŠEwÈüëã'O¤¼°§}‡F”Oüq—S2ÒÜÄ1!İÌ`H­£Õ¸A
 ´‰6ğĞÖíß~)8‰@¦FAÖ“biîc ì’Si¾!Cc$×4HBñd“ìº7ÌkÿÀ¡äRFyD¢5xóò§Y|ÁCğeûw³Å|ıà¥¬¦›T·¸Õ!AÕ©ÿjK‹ÆQçÑçqLDÚè9™×ôŠ^NGŠûJıZcZ˜­AF“«-?©Yù½'ÏˆÅ7‡ÜÚÇTN÷õ¸|{z¶÷¬Á$·iÖ¨³¹Ì¦ş &‡³]8:{ÏÆS„­‡Ùs(ÁŞåÇıKbùö\ÏÌ®¬¨½ñ"zÏÊÓ™ _˜<wJÉÏ†ázîéRŒ÷_'›<^ôO†
	dÅ©‰wäCM©Ù¸š²ky– >>Âƒ­vÓöÉ¼Õ–‡™”&w¢©lêèù&»úÛ‰&¡³v0ó^Ãè„¾¶¨È,¶D3°ÆypO±\š¶ñÌÆ¨£€ Á´  obñ™ò}†ÃîÜE6pëU1qêxğ't)]]¥Seìm‰’AU¥*÷¥ãæœv•b<âğşàöQ˜›•î´óh‰Ğ42äª?V¯cpğÓ8ÖÛzOE”2 ;¯£jGJÍÛ@}égîİîÅÚB0Ñ¦T(õÀGë­zr;B?)I­³Ç`´ÖÓ'ù/Æ}láhYêŞ¡~´=‹$Ét>.@W~ùøÓ ğ(ñ^¡\l’Pò,Rl¦H,M Ş¦e´±½8`ôNå(un}|^6rásƒ_÷R…ì$/_˜*/ö–Ó¾Á„S²tù*G™›?Òªsc7çZ±Hİ¬ì<Šö„ş÷ôRŠpQÁ’8æƒˆ¤Ÿ–Ã[ãô•ßãÂO˜hU§o"'Úû$*1¨êÚ05Ø€‹ËÖ¥Ú÷¬4™AHÕ7Íğ)|Ü‚¼îšĞÿzáÜkmØLÆ[Ä
?Æµs>ıîÎ—O¨¸$»HÉ‰Oiµş€Û¹G(Ææk¤› ™íîÿæœ$†Ş™mš¤š¶WêI¿g+‰ä]eø‚¯çZJ{='¬jE–¹F¤7.oÎsDÙŞ¨Æş'x8lëù¿ZfŒÚ vOCm¸._MKôR[*ÿLÿ³QkŸæw× r‘… ì+cùtÑ$Œ:€~P5aæ®`2ß/Œ‡†×ğşo™Ä5ŠãŸ#|QÅ f3¢ æíÅº°ßƒ E{/PJõ9 Rıu³|oâ¤¾²F©¾ì ºg“5ü‹ê@6qÖ/§—
ôûØ-‘3PBñ!z|ØË, )åBR$Â…ÂŒÍ1Üõü¼9\åÑì²®"—Ï—[ÕK†%ÒÄ×Q4v±—u«©ÿOBàÇvøĞÅıš$FVWêèKÄÚ™. ½7^ù½À/¶b^s*{øÉ+•áó&“³‹äRFyæqLª‹ÈQ.É¦ µ#£Å;øÜåéÕX·ôœr½ÍR­pKƒ•´‚¤>qŸŠ8—Ô±·O*ùÁÏ^3ô†LWÇÔS@âAMÃ¾Â+æ“ß"Òâ_õà¥2n*ªåûÂ;µ ‰û³şÊ¤¿¡;ŞàZ92{›ÒBèéÎÒw4ÛÑ‹ª‘%As¿¾äÀüÏÅ Cü¥g(†‹ÚÚ¡_İ5[Z}Qš˜ı“uı AÂ¤@%‹s_·^¥6K[#–³‰6ª<Ô™ìÜ¿v{›6?— ª\ÓöÉ¼ÕÓÊÚVz‚9|¯³:ü””DÛ†Öv¸ì7{åEÍªìÇæç†K¬&fü€\rù•ùòÅÍ®¹ÓjDŒöEòoB$´–â}ËÕWïˆs#êY7rı=Õ:wlULû1«/‹œAF†ÿj-İ¥ãæœv•'q¡¤–õáF—‚¢òâG`ˆrn´µ3oD²eq¤Ó	ÓØ˜v[C”<®6¦ª'	q·]˜1¥>î‰êß<Ë¯>ªÀ ¾br!@8c®·OÖ2ñìøü ÒÏt%~ühJ¤©Íñq¦Étq`HM]0ß§”÷.êI!¥tSõs&ë*
T@Şúmµì²8}ş|(¢eY%:x<C>(™±f™Wéüƒv|PÌNy"¦˜Ï÷É—B¹r°$¾¬îÛsh7çF¶Üàá7œî’Vµˆ­ôZØ5ÒÜk©™è–‹‚ÄS±¾ÚŒ©‡Aƒ!~ş!k<Üó;O^ø¸•f|œÅ‹Å˜D¯Âæ§8×Ob¬r¥{9¿Íò Õ“Ë/¨ˆrvŒšGÒ\›YIsRÛé*<÷	ªˆËO¨¸(è¡ú'òşÍší5	n%ğ‡œóÜ_¾­¿…±(†’ĞW9IÔ¤ü°N-©m+ˆí*$Î–€«ù[#mÆ%«9Ñö²:50Õ/ßœXÄ¨•ªuxw%½ø¥#ÓÅ_/aYlùgWÂBS)èPWÚÕ%Úæï"‘s‡dÌN¦n{óohCÉ œ-}nt(¨H¢`~–|—Œ‹¯¨"Ùt‹ğp2W‡yQ-iöx¶¨Áïù“„Kn5PKØRN†º|r£¯›¿çS¤á»áQü{¨‘êl#ENê)±Ï ìíÓ~‡3dÁO@ØÊAcæ(åk
ÔË‡ İmB†®¹òwıÍàì§ZÂ  ÃºlËKÙÉl–ÍÍ$z”=eÄçÕ­
¥‰m¬“‡¦š1VJF“@¡KÅJ“ú-' &Xãÿc÷L6#o‹._RøÓ6ß©ì:Ü{³‰çÃ­]Tn¢5xùßY[2‚ø ­2÷‘&FºÊÿõÒI°´Õm«×R±/‘ÆY´”¾"vNÑòm³Ç²£I	4ä‰JĞUYmıÈJ•ªbmÈAMÃ¾ÂjVÄ™É~ÊâH £¢ #-Pb¦§®8»tÑ¾±ò„áù¨ Š¥Hu`˜Øµˆ‰,f„ßğ˜inÿ÷{‰Uçâï Cüõ5mÖÎÑÓ„B†$HQvW‚ßá!ºóI¾W/Å<_ò^îvO[~Å¡‡yêîÃìÜ¼wm¬)~q‘“€
Rš²À¦ŞÎÀ_ío9á_©:ûû§eî¤Ëb›ë7j§ˆª¡Ñàí†x¶+PÉ¶ke]³R™åø„ï»óÂ³èoJv´ˆûfÃDM¡¾B5büN}'²f¶#pmüNcâ>ßşzÈäGİ¥³´Ù&BÛ&P¡£ÊõùF‹ŞĞô°ÿO.”•67æ£sYµo|êÔg†Ò—`]HÑ,ûyâæfZ \ËÑE8¿>ºÁô÷?yêTj°À»©~n+I{R±ªDİm£†èìÙÜn"o‹àdD¤µì<½8õZŒĞÛ&$.H[N-ÂòÚS£öA ìF1Æ¿6,µ8Öû1ËÜ²y3§U«ei~6D>MÊâf”PÿEÙì 9˜Ty%í’Ø³Ã† û&æmL…Š<Ûû,;oäA« Ğ‚ø8‰ÿ…ğÇ©ôÅ9ÅXÛ’l¤Ê»ïóî‚ã·Ú‘·‡G-j²u/Úù-8:b¬ıÛ#.”€İÏ˜ğ”ğ½>„"ó7¹z(™Ìù¼ŠĞ—&ª†m‹Å	Ö@Ø"<sRÛé*<÷	ªˆËO¨¸(è¡ú'òşÍší*Âe/ËÓ<ŞÌĞ_¹¡¾ä,ÃˆÜJ9šæ­…kÈo-©n-‰ğu# ]œ½ÿH{!Üsì" ‹¼D¨!9yÎ]P™Ú–¡•·kY`0)¯P¬ñZkİ[+şkWVWKÆUX<ÿ½×.óVµÙ2™dİ